"""
Text Input Chat Screen Test Module
Based on TextInputChatScreen, used for testing new features
"""

from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.textinput import TextInput
from kivy.uix.label import Label
from kivy.uix.button import Button
from kivy.uix.scrollview import ScrollView
from kivy.uix.gridlayout import GridLayout
from kivy.clock import Clock
from kivy.graphics import Color, Rectangle

class TextInputChatScreenTest(Screen):
    """Text Input Chat Screen Test Version"""
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        print("üöÄ TextInputChatScreenTest __init__ started")
        
        self.chat_history = []
        self.selected_text_backup = ""
        self.is_text_selected = False
        self.selection_start = 0
        self.selection_end = 0
        
        # Article data
        self.article_title = "Test Article"
        self.article_content = """The Internet and Language Learning

The internet has revolutionized the way we learn languages. With the advent of online platforms, mobile applications, and digital resources, language learning has become more accessible than ever before.

Online language learning platforms offer a variety of features that traditional classroom settings cannot provide. These include interactive exercises, real-time feedback, personalized learning paths, and access to native speakers from around the world.

One of the most significant advantages of internet-based language learning is the availability of authentic materials. Learners can access real news articles, videos, podcasts, and social media content in their target language.

Furthermore, the internet facilitates collaborative learning through online communities and language exchange programs. Students can connect with peers from different countries, practice conversation skills, and share cultural insights."""
        
        print("üìö Article data set, initializing MainAssistant...")
        # Initialize MainAssistant and DataController
        self._initialize_main_assistant()
        print("‚úÖ MainAssistant initialization completed")
        
        print("üîß Setting up UI...")
        self._setup_ui()
        print("üîß Binding events...")
        self._bind_events()
        
        # Selection state variables
        self.selection_start_index = -1
        self.selection_end_index = -1
        self.is_dragging = False
        self.selected_indices = set()  # Store all selected token indices
        self.last_touch_time = 0  # Record last touch time for continuous click detection
        self.touch_timeout = 0.5  # Continuous click time window (seconds)
        
        # New: Smart question control related variables
        self.previous_context_tokens = []  # Previous conversation context sentence tokens
        self.previous_context_sentence = ""  # Previous conversation complete sentence
        self.previous_context_sentence_id = -1  # Previous conversation sentence ID
        self.last_used_tokens = []  # Recently used tokens (for follow-up questions)
    
    def _initialize_main_assistant(self):
        """Initialize MainAssistant and DataController"""
        try:
            print("ü§ñ Starting MainAssistant initialization...")
            
            # Import required modules
            print("üì¶ Importing MainAssistant...")
            from assistants.main_assistant import MainAssistant
            print("üì¶ Importing DataController...")
            from data_managers import data_controller
            print("‚úÖ All imports successful")
            
            # Create DataController instance
            print("üîß Creating DataController...")
            self.data_controller = data_controller.DataController(max_turns=100)
            print("‚úÖ DataController created")
            
            # Load existing data if available
            try:
                print("üìÇ Loading existing data...")
                self.data_controller.load_data(
                    grammar_path='data/grammar_rules.json',
                    vocab_path='data/vocab_expressions.json',
                    text_path='data/original_texts.json',
                    dialogue_record_path='data/dialogue_record.json',
                    dialogue_history_path='data/dialogue_history.json'
                )
                print("‚úÖ Successfully loaded existing data")
            except FileNotFoundError as e:
                print(f"‚ö†Ô∏è Some data files not found, starting with empty data: {e}")
            except Exception as e:
                print(f"‚ö†Ô∏è Error loading data, starting with empty data: {e}")
            
            # Create MainAssistant instance with DataController
            print("üîß Creating MainAssistant...")
            self.main_assistant = MainAssistant(data_controller_instance=self.data_controller)
            print("‚úÖ MainAssistant created")
            
            print("‚úÖ MainAssistant initialized successfully")
            print(f"üìä Current data status:")
            print(f"   - Grammar rules: {len(self.data_controller.grammar_manager.get_all_rules_name())}")
            print(f"   - Vocabulary items: {len(self.data_controller.vocab_manager.get_all_vocab_body())}")
            print(f"   - Original texts: {len(self.data_controller.text_manager.list_texts_by_title())}")
            
        except ImportError as e:
            print(f"‚ùå Failed to import required modules: {e}")
            import traceback
            traceback.print_exc()
            print("‚ö†Ô∏è MainAssistant will not be available, using fallback AI responses")
            self.main_assistant = None
            self.data_controller = None
        except Exception as e:
            print(f"‚ùå Failed to initialize MainAssistant: {e}")
            import traceback
            traceback.print_exc()
            print("‚ö†Ô∏è MainAssistant will not be available, using fallback AI responses")
            self.main_assistant = None
            self.data_controller = None
    
    def _save_data(self):
        """Save data to files"""
        if self.data_controller:
            try:
                self.data_controller.save_data(
                    grammar_path='data/grammar_rules.json',
                    vocab_path='data/vocab_expressions.json',
                    text_path='data/original_texts.json',
                    dialogue_record_path='data/dialogue_record.json',
                    dialogue_history_path='data/dialogue_history.json'
                )
                print("‚úÖ Data saved successfully")
            except Exception as e:
                print(f"‚ùå Failed to save data: {e}")
    
    def _convert_to_sentence_object(self, selected_tokens, full_sentence, sentence_id, user_input):
        """Convert UI selection data to MainAssistant expected Sentence object"""
        from data_managers.data_classes import Sentence
        
        # Construct Sentence object
        sentence_object = Sentence(
            text_id=getattr(self, 'article_id', 0),
            sentence_id=sentence_id,
            sentence_body=full_sentence,
            grammar_annotations=[],  # Empty for now, will be filled by AI later
            vocab_annotations=[]     # Empty for now, will be filled by AI later
        )
        
        print(f"üîÑ Converted to Sentence object:")
        print(f"   text_id: {sentence_object.text_id}")
        print(f"   sentence_id: {sentence_object.sentence_id}")
        print(f"   sentence_body: '{sentence_object.sentence_body}'")
        print(f"   selected_tokens: {selected_tokens}")
        print(f"   user_input: '{user_input}'")
        
        return sentence_object
    
    def _call_main_assistant(self, sentence_object, user_question, selected_tokens):
        """Call MainAssistant to process the user question"""
        if not self.main_assistant:
            print("‚ö†Ô∏è MainAssistant not available, using fallback response")
            return self._generate_fallback_response(user_question, sentence_object.sentence_body)
        
        try:
            print("ü§ñ Calling MainAssistant...")
            
            # Convert selected tokens to quoted string
            quoted_string = " ".join(selected_tokens) if selected_tokens else None
            
            # Call MainAssistant
            self.main_assistant.run(
                quoted_sentence=sentence_object,
                user_question=user_question,
                quoted_string=quoted_string
            )
            
            # Get the AI response from MainAssistant's session state
            if self.main_assistant and self.main_assistant.session_state:
                ai_response = self.main_assistant.session_state.current_response
                if ai_response:
                    print("‚úÖ MainAssistant response received")
                    return ai_response
            
            # Fallback if no response found
            print("‚ö†Ô∏è No AI response found, using fallback")
            return self._generate_fallback_response(user_question, sentence_object.sentence_body)
            
        except Exception as e:
            print(f"‚ùå Error calling MainAssistant: {e}")
            print("‚ö†Ô∏è Using fallback response")
            return self._generate_fallback_response(user_question, sentence_object.sentence_body)
    
    def _generate_fallback_response(self, user_question, sentence_body):
        """Generate fallback response when MainAssistant is not available"""
        if sentence_body:
            return f"Fallback response: I understand you're asking about '{sentence_body[:50]}...'. This is a fallback response as the AI assistant is not fully available."
        else:
            return "Fallback response: I'm here to help with language learning. Please select some text and ask me questions about grammar, vocabulary, or meaning."
    
    def set_article(self, article_data):
        """Set article data"""
        if hasattr(article_data, 'text_title'):
            self.article_title = article_data.text_title
        else:
            self.article_title = "Test Article"
        
        if hasattr(article_data, 'text_by_sentence'):
            # Convert sentence list to text
            sentences = []
            for sentence in article_data.text_by_sentence:
                sentences.append(sentence.sentence_body)
            self.article_content = " ".join(sentences)
        else:
            self.article_content = "Article content not available."
        
        # Save article ID
        if hasattr(article_data, 'text_id'):
            self.article_id = article_data.text_id
        else:
            self.article_id = 0  # Default ID
        
        # Update UI display
        self._update_article_display()
        print(f"üìñ Set article: {self.article_title} (ID: {self.article_id})")
        print(f"üìù Article content length: {len(self.article_content)} characters")
    
    def _update_article_display(self):
        """Update article display"""
        if hasattr(self, 'article_title_label'):
            self.article_title_label.text = f'Test Article: {self.article_title}'
        
        # Recreate article content (if needed)
        if hasattr(self, 'tokens'):
            self._recreate_article_content()
    
    def _tokenize_text(self, text):
        """Tokenize text into words/phrases, merge punctuation with adjacent words, and group by sentences"""
        import re
        
        # Define punctuation categories
        # Post-punctuation: should merge with previous word
        post_punctuation = r'[,\.!‚Ä¶?\)\]\}""'']'
        # Pre-punctuation: should merge with next word
        pre_punctuation = r'[\(\[\{"'']'
        
        # Step 1: Split text by sentences
        sentence_endings = r'[„ÄÇÔºÅÔºü\.!?\n]'
        sentences = re.split(f'({sentence_endings})', text)
        
        # Recombine sentences, preserving sentence ending punctuation
        sentence_blocks = []
        current_sentence = ""
        for i, part in enumerate(sentences):
            if re.match(sentence_endings, part):
                # This is sentence ending punctuation
                current_sentence += part
                if current_sentence.strip():
                    sentence_blocks.append(current_sentence.strip())
                current_sentence = ""
            else:
                # This is sentence content
                current_sentence += part
        
        # Handle the last sentence (if no ending punctuation)
        if current_sentence.strip():
            sentence_blocks.append(current_sentence.strip())
        
        # Step 2: Tokenize each sentence
        all_tokens = []
        sentence_boundaries = []
        token_index = 0
        
        for sentence_id, sentence in enumerate(sentence_blocks):
            # Pre-process contractions
            sentence = re.sub(r"(\w+)'(\w+)", r"\1'\2", sentence)
            
            # Tokenize with punctuation merging
            tokens = re.findall(r'\b\w+(?:[,\-\.!‚Ä¶?\)\]\}""'']+)?|[\w\s]*[\(\[\{"'']\w+|\w+[,\-\.!‚Ä¶?\)\]\}""'']+|\w+', sentence)
            
            # Post-process tokens
            processed_tokens = []
            for token in tokens:
                token = token.strip()
                if token:
                    # Clean up redundant punctuation
                    token = re.sub(r'([,\-\.!‚Ä¶?\)\]\}""''])\1+', r'\1', token)
                    processed_tokens.append(token)
            
            # Store sentence boundary information
            sentence_start = token_index
            sentence_end = token_index + len(processed_tokens) - 1
            sentence_boundaries.append({
                'start': sentence_start,
                'end': sentence_end,
                'sentence_id': sentence_id,
                'text': sentence
            })
            
            all_tokens.extend(processed_tokens)
            token_index += len(processed_tokens)
        
        return all_tokens, sentence_boundaries
    
    def _recreate_article_content(self):
        """ÈáçÊñ∞ÂàõÂª∫ÊñáÁ´†ÂÜÖÂÆπÔºåÊåâÂè•Â≠êÂàÜÁªÑ"""
        # Ê∏ÖÈô§Áé∞ÊúâÂÜÖÂÆπ
        if hasattr(self, 'article_content_container'):
            self.article_content_container.clear_widgets()
        
        # ÈáçÊñ∞ÂàÜËØç
        self.tokens, self.sentence_boundaries = self._tokenize_text(self.article_content)
        self.token_widgets = []
        
        # ÊåâÂè•Â≠êÂàõÂª∫UI
        for sentence_boundary in self.sentence_boundaries:
            # ÂàõÂª∫Âè•Â≠êÂÆπÂô®
            sentence_container = BoxLayout(
                orientation='vertical', 
                size_hint_y=None, 
                spacing=5,
                padding=(10, 5)
            )
            sentence_container.sentence_id = sentence_boundary['sentence_id']
            
            # ÂàõÂª∫Âè•Â≠êÂÜÖÁöÑtokenË°å
            current_line = BoxLayout(orientation='horizontal', size_hint_y=None, height=60, spacing=5)
            line_width = 0
            
            # Ëé∑ÂèñÂΩìÂâçÂè•Â≠êÁöÑtokenËåÉÂõ¥
            start_token = sentence_boundary['start']
            end_token = sentence_boundary['end']
            
            for i in range(start_token, end_token + 1):
                if i >= len(self.tokens):
                    break
                    
                token = self.tokens[i]
                token_label = Label(
                    text=token,
                    size_hint=(None, None),
                    size=(len(token) * 30, 50),
                    color=(0.2, 0.2, 0.2, 1),
                    font_size=48,
                    halign='left',
                    valign='middle',
                    padding=(5, 5)
                )
                
                with token_label.canvas.before:
                    Color(1, 1, 1, 1)
                    token_label.token_bg = Rectangle(pos=token_label.pos, size=token_label.size)
                
                token_label.bind(
                    pos=self._update_token_bg,
                    size=self._update_token_bg,
                    on_touch_down=self._on_token_touch_down,
                    on_touch_move=self._on_token_touch_move,
                    on_touch_up=self._on_token_touch_up
                )
                
                token_label.token_index = i
                token_label.token_text = token
                token_label.is_selected = False
                token_label.sentence_id = sentence_boundary['sentence_id']  # Ê∑ªÂä†Âè•Â≠êID
                
                self.token_widgets.append(token_label)
                
                # Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊç¢Ë°å
                if line_width + len(token) * 30 > 1200:
                    sentence_container.add_widget(current_line)
                    current_line = BoxLayout(orientation='horizontal', size_hint_y=None, height=60, spacing=5)
                    line_width = 0
                
                current_line.add_widget(token_label)
                line_width += len(token) * 30 + 5
            
            # Ê∑ªÂä†ÊúÄÂêé‰∏ÄË°å
            if current_line.children:
                sentence_container.add_widget(current_line)
            
            # ËÆ°ÁÆóÂè•Â≠êÂÆπÂô®ÁöÑÂÆûÈôÖÈ´òÂ∫¶
            sentence_height = len(sentence_container.children) * 65  # ÊØèË°å65ÂÉèÁ¥†
            sentence_container.height = sentence_height
            
            # Â∞ÜÂè•Â≠êÂÆπÂô®Ê∑ªÂä†Âà∞‰∏ªÂÆπÂô®
            self.article_content_container.add_widget(sentence_container)
        
        # ËÆ°ÁÆóÊÄªÈ´òÂ∫¶
        total_height = sum(child.height for child in self.article_content_container.children) + len(self.article_content_container.children) * 10
        self.article_content_container.height = total_height
    
    def _go_back(self, instance):
        """ËøîÂõû‰∏ªÈ°µÈù¢"""
        print("‚¨ÖÔ∏è Returning to main page")
        # Check if main screen exists
        if hasattr(self.manager, 'screens') and any(screen.name == "main" for screen in self.manager.screens):
            self.manager.current = "main"
        else:
            print("‚ö†Ô∏è Main screen not found, closing application")
            from kivy.app import App
            App.get_running_app().stop()
    
    def _setup_ui(self):
        """ËÆæÁΩÆUIÁïåÈù¢"""
        # ‰∏ªÂ∏ÉÂ±Ä
        main_layout = BoxLayout(orientation='vertical', padding=10, spacing=10)
        
        # ‰∏äÊñπÔºöÊñáÁ´†ÈòÖËØªÂå∫Âüü
        reading_panel = self._create_reading_panel()
        main_layout.add_widget(reading_panel)
        
        # ‰∏ãÊñπÔºöËÅäÂ§©Âå∫Âüü
        chat_panel = self._create_chat_panel()
        main_layout.add_widget(chat_panel)
        
        self.add_widget(main_layout)
    
    def _create_reading_panel(self):
        """ÂàõÂª∫ÊñáÁ´†ÈòÖËØªÈù¢Êùø"""
        reading_panel = BoxLayout(orientation='vertical', size_hint_y=0.6, spacing=10)
        
        # È°∂ÈÉ®Ê†èÔºàËøîÂõûÊåâÈíÆ + ÊñáÁ´†Ê†áÈ¢òÔºâ
        top_bar = self._create_top_bar()
        reading_panel.add_widget(top_bar)
        
        # ÊñáÁ´†ÂÜÖÂÆπ
        article_content = self._create_article_content()
        reading_panel.add_widget(article_content)
        
        # ÈÄâÊã©Áä∂ÊÄÅÊ†áÁ≠æ
        selection_label = self._create_selection_label()
        reading_panel.add_widget(selection_label)
        
        return reading_panel
    
    def _create_top_bar(self):
        """ÂàõÂª∫È°∂ÈÉ®Ê†è"""
        top_bar = BoxLayout(orientation='horizontal', size_hint_y=None, height=50, spacing=10)
        
        # ËøîÂõûÊåâÈíÆ
        back_btn = Button(
            text='‚Üê Back',
            size_hint_x=None,
            width=100,
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1),
            font_size=16
        )
        back_btn.bind(on_press=self._go_back)
        
        # ÊñáÁ´†Ê†áÈ¢ò
        self.article_title_label = Label(
            text='Test Article: Article Title',
            size_hint_x=1,
            color=(0.2, 0.2, 0.2, 1),
            font_size=18,
            bold=True,
            halign='left',
            valign='middle'
        )
        
        top_bar.add_widget(back_btn)
        top_bar.add_widget(self.article_title_label)
        
        return top_bar
    
    def _create_article_title(self):
        """ÂàõÂª∫ÊñáÁ´†Ê†áÈ¢ò"""
        title_label = Label(
            text='Test Article: Article Title',
            size_hint_y=None,
            height=40,
            color=(0.2, 0.2, 0.2, 1),
            font_size=18,
            bold=True,
            halign='left',
            valign='middle'
        )
        return title_label
    
    def _create_article_content(self):
        """ÂàõÂª∫ÊñáÁ´†ÂÜÖÂÆπÂå∫Âüü - Âü∫‰∫éËØç/Áü≠ËØ≠ÁöÑÈÄâÊã©"""
        # ÊªöÂä®ËßÜÂõæ
        scroll_view = ScrollView(size_hint=(1, 1))
        
        # ÂàõÂª∫ÊñáÁ´†ÂÜÖÂÆπÂÆπÂô®
        self.article_content_container = BoxLayout(
            orientation='vertical',
            size_hint_y=None,
            height=400,
            padding=(10, 10),
            spacing=5
        )
        
        # ÁªëÂÆöÂÆπÂô®ÁöÑËß¶Êë∏‰∫ã‰ª∂ÔºåÁî®‰∫éÁÇπÂáªÁ©∫ÁôΩÂ§ÑÂèñÊ∂àÈÄâÊã©
        self.article_content_container.bind(
            on_touch_down=self._on_container_touch_down,
            on_touch_move=self._on_container_touch_move,
            on_touch_up=self._on_container_touch_up
        )
        
        # ÂàÜËØçÂπ∂ÂàõÂª∫ÂèØÈÄâÊã©ÁöÑËØç/Áü≠ËØ≠
        self.tokens, self.sentence_boundaries = self._tokenize_text(self.article_content)
        self.token_widgets = []
        
        # ÂàõÂª∫ËØç/Áü≠ËØ≠Ê†áÁ≠æ
        current_line = BoxLayout(orientation='horizontal', size_hint_y=None, height=60, spacing=5)
        line_width = 0
        
        for i, token in enumerate(self.tokens):
            # ÂàõÂª∫ËØç/Áü≠ËØ≠Ê†áÁ≠æ
            token_label = Label(
                text=token,
                size_hint=(None, None),
                size=(len(token) * 30, 50),  # Ê†πÊçÆÊñáÊú¨ÈïøÂ∫¶Ë∞ÉÊï¥ÂÆΩÂ∫¶
                color=(0.2, 0.2, 0.2, 1),
                font_size=48,
                halign='left',
                valign='middle',
                padding=(5, 5)
            )
            
            # ‰∏∫ÊØè‰∏™ËØç/Áü≠ËØ≠Ê∑ªÂä†ËÉåÊôØÂíåÁÇπÂáª‰∫ã‰ª∂
            with token_label.canvas.before:
                Color(1, 1, 1, 1)  # ÁôΩËâ≤ËÉåÊôØ
                self.token_bg = Rectangle(pos=token_label.pos, size=token_label.size)
            
            # ÁªëÂÆö‰∫ã‰ª∂
            token_label.bind(
                pos=self._update_token_bg,
                size=self._update_token_bg,
                on_touch_down=self._on_token_touch_down,
                on_touch_move=self._on_token_touch_move,
                on_touch_up=self._on_token_touch_up
            )
            
            # Â≠òÂÇ®token‰ø°ÊÅØ
            token_label.token_index = i
            token_label.token_text = token
            token_label.is_selected = False
            
            self.token_widgets.append(token_label)
            
            # Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊç¢Ë°å
            if line_width + len(token) * 30 > 1200:  # ÂÅáËÆæÊúÄÂ§ßÂÆΩÂ∫¶1200
                self.article_content_container.add_widget(current_line)
                current_line = BoxLayout(orientation='horizontal', size_hint_y=None, height=60, spacing=5)
                line_width = 0
            
            current_line.add_widget(token_label)
            line_width += len(token) * 30 + 5
        
        # Ê∑ªÂä†ÊúÄÂêé‰∏ÄË°å
        if current_line.children:
            self.article_content_container.add_widget(current_line)
        
        # ËÆæÁΩÆÂÆπÂô®È´òÂ∫¶
        self.article_content_container.height = len(self.article_content_container.children) * 65
        
        scroll_view.add_widget(self.article_content_container)
        return scroll_view
    
    def _create_selection_label(self):
        """ÂàõÂª∫ÈÄâÊã©Áä∂ÊÄÅÊ†áÁ≠æ"""
        self.selection_label = Label(
            text='No text selected',
            size_hint_y=None,
            height=120,  # Â¢ûÂä†È´òÂ∫¶‰ª•ÈÄÇÂ∫îÊõ¥Â§ßÁöÑÂ≠ó‰Ωì
            color=(0.5, 0.5, 0.5, 1),
            font_size=42,  # ‰ªé14ÊîæÂ§ßÂà∞42 (Á∫¶‰∏âÂÄç)
            halign='left',
            valign='middle'
        )
        return self.selection_label
    
    def _create_chat_panel(self):
        """ÂàõÂª∫ËÅäÂ§©Èù¢Êùø"""
        chat_panel = BoxLayout(orientation='vertical', size_hint_y=0.4, spacing=10)
        
        # ËÅäÂ§©Ê†áÈ¢ò
        chat_title = self._create_chat_title()
        chat_panel.add_widget(chat_title)
        
        # ËÅäÂ§©ÊªöÂä®Âå∫Âüü
        self.chat_scroll, self.chat_container = self._create_chat_scroll_area()
        chat_panel.add_widget(self.chat_scroll)
        
        # ËæìÂÖ•Âå∫Âüü
        input_layout = self._create_input_layout()
        chat_panel.add_widget(input_layout)
        
        return chat_panel
    
    def _create_chat_title(self):
        """ÂàõÂª∫ËÅäÂ§©Ê†áÈ¢ò"""
        title_label = Label(
            text='Test AI Assistant Chat',
            size_hint_y=None,
            height=40,
            color=(0.2, 0.2, 0.2, 1),
            font_size=16,
            bold=True,
            halign='left',
            valign='middle'
        )
        return title_label
    
    def _create_chat_scroll_area(self):
        """ÂàõÂª∫ËÅäÂ§©ÊªöÂä®Âå∫Âüü"""
        # ÊªöÂä®ËßÜÂõæ
        chat_scroll = ScrollView(size_hint=(1, 1))
        
        # ËÅäÂ§©ÂÆπÂô®
        chat_container = GridLayout(
            cols=1,
            size_hint_y=None,
            spacing=10,
            padding=(10, 10)
        )
        
        # ËÆæÁΩÆËÉåÊôØ
        with chat_container.canvas.before:
            Color(0.95, 0.95, 0.95, 1)
            self.chat_container_bg = Rectangle(pos=chat_container.pos, size=chat_container.size)
        chat_container.bind(pos=self._update_chat_container_bg, size=self._update_chat_container_bg)
        chat_container.bind(minimum_height=lambda instance, value: setattr(chat_container, 'height', value))
        
        chat_scroll.add_widget(chat_container)
        return chat_scroll, chat_container
    
    def _create_input_layout(self):
        """ÂàõÂª∫ËæìÂÖ•Â∏ÉÂ±Ä"""
        input_layout = BoxLayout(orientation='horizontal', size_hint_y=None, height=50, spacing=10)
        
        # ËæìÂÖ•Ê°Ü
        self.chat_input = TextInput(
            text='',
            size_hint_x=0.8,
            multiline=False,
            background_color=(1, 1, 1, 1),
            foreground_color=(0.2, 0.2, 0.2, 1),
            font_size=16,
            padding=(10, 10),
            hint_text='Type your message here...'
        )
        self.chat_input.bind(on_text_validate=self._on_send_message)
        
        # ÂèëÈÄÅÊåâÈíÆ
        send_btn = Button(
            text='Send',
            size_hint_x=0.2,
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1),
            font_size=16
        )
        send_btn.bind(on_press=self._on_send_message)
        
        input_layout.add_widget(self.chat_input)
        input_layout.add_widget(send_btn)
        
        return input_layout
    
    def _bind_events(self):
        """ÁªëÂÆö‰∫ã‰ª∂"""
        # Ê∑ªÂä†Ê¨¢ËøéÊ∂àÊÅØ
        Clock.schedule_once(lambda dt: self._add_chat_message("Test AI Assistant", "Hello! I'm here to help you with language learning. You can select any text from the article and ask me questions about it.", is_ai=True), 0.5)
    
    def _block_input(self, text, from_undo):
        """ÈòªÊ≠¢ËæìÂÖ•ÔºàÁî®‰∫éÂè™ËØªÊñáÊú¨Ôºâ"""
        return False
    
    def _on_chat_input_focus(self, instance, value):
        """ËÅäÂ§©ËæìÂÖ•Ê°ÜÁÑ¶ÁÇπ‰∫ã‰ª∂"""
        if value:  # Ëé∑ÂæóÁÑ¶ÁÇπ
            # ‰ΩøÁî®tokenÈÄâÊã©Êú∫Âà∂Ôºå‰øùÊåÅÂΩìÂâçÈÄâÊã©Áä∂ÊÄÅ
            if self.selected_text_backup and self.is_text_selected:
                print(f"üéØ Input box gained focus, keeping selected text: '{self.selected_text_backup}'")
            else:
                print("üéØ Input box gained focus, no text selected")
        else:  # Â§±ÂéªÁÑ¶ÁÇπ
            print(f"üéØ Input box lost focus, current selected text: '{self.selected_text_backup}'")
    
    def _on_text_selection_change(self, instance, value):
        """ÊñáÊú¨ÈÄâÊã©ÂèòÂåñ‰∫ã‰ª∂Ôºà‰øùÁïôÁî®‰∫éÂÖºÂÆπÊÄßÔºâ"""
        # Ëøô‰∏™ÊñπÊ≥ïÁé∞Âú®‰∏ªË¶ÅÁî®‰∫éÂÖºÂÆπÊÄßÔºåÂÆûÈôÖÈÄâÊã©Áî±tokenÊú∫Âà∂Â§ÑÁêÜ
        pass
    
    def _update_selection_display(self, dt=None):
        """Êõ¥Êñ∞ÈÄâÊã©Áä∂ÊÄÅÊòæÁ§∫"""
        # ‰ΩøÁî®tokenÈÄâÊã©Êú∫Âà∂
        has_backup = self.selected_text_backup and self.is_text_selected
        
        if has_backup:
            # ÊúâÈÄâ‰∏≠ÁöÑÊñáÊú¨
            selected_text = self.selected_text_backup[:50] + "..." if len(self.selected_text_backup) > 50 else self.selected_text_backup
            self.selection_label.text = f'Selected: "{selected_text}"'
            self.selection_label.color = (0.2, 0.6, 1, 1)
            print(f"üìù Displaying selection: '{selected_text}'")
        else:
            # Ê≤°Êúâ‰ªª‰ΩïÈÄâÊã©
            self.selection_label.text = "No selection"
            self.selection_label.color = (0.5, 0.5, 0.5, 1)
            print("üìù Clearing selection display")
    
    def _get_selected_text(self):
        """Ëé∑ÂèñÂΩìÂâçÈÄâ‰∏≠ÁöÑÊñáÊú¨"""
        # ‰ΩøÁî®tokenÈÄâÊã©Êú∫Âà∂
        if self.selected_text_backup and self.is_text_selected:
            return self.selected_text_backup
        return ""
    
    def _keep_text_highlighted(self):
        """‰øùÊåÅÊñáÊú¨È´ò‰∫Æ"""
        # ËøôÈáåÂèØ‰ª•Ê∑ªÂä†‰øùÊåÅÊñáÊú¨È´ò‰∫ÆÁöÑÈÄªËæë
        pass
    
    def _force_selection_update(self, dt):
        """Âº∫Âà∂Êõ¥Êñ∞ÈÄâÊã©Áä∂ÊÄÅ"""
        # ËøôÈáåÂèØ‰ª•Ê∑ªÂä†Âº∫Âà∂Êõ¥Êñ∞ÈÄâÊã©Áä∂ÊÄÅÁöÑÈÄªËæë
        pass
    
    def _on_send_message(self, *args):
        """ÂèëÈÄÅÊ∂àÊÅØ - Êô∫ËÉΩÊèêÈóÆÊéßÂà∂ÈÄªËæë"""
        message = self.chat_input.text.strip()
        if not message:
            return
        
        # Ëé∑ÂèñÂΩìÂâçÈÄâ‰∏≠ÁöÑÊñáÊú¨Âíåtokens
        selected_text = self._get_selected_text()
        current_selected_tokens = []
        current_sentence_info = None
        
        if selected_text and self.selected_indices:
            # ÊûÑÈÄ†ÂΩìÂâçÈÄâ‰∏≠ÁöÑtokens
            for i in sorted(self.selected_indices):
                if 0 <= i < len(self.tokens):
                    current_selected_tokens.append(self.tokens[i])
            
            # Ëé∑ÂèñÂΩìÂâçÂè•Â≠êÁöÑÂÆåÊï¥‰ø°ÊÅØ
            current_sentence_info = self._get_full_sentence_info(self.selected_indices)
        
        # üß† Êô∫ËÉΩÊèêÈóÆÊéßÂà∂ÈÄªËæë
        context_tokens = []
        context_sentence = ""
        context_sentence_id = -1
        is_follow_up = False
        
        if current_selected_tokens:
            # ÊÉÖÂÜµ1ÔºöÂΩìÂâçËΩÆÁî®Êà∑ÊúâÈÄâ‰∏≠token
            print("üéØ Using current selected tokens as context")
            context_tokens = current_selected_tokens
            context_sentence = current_sentence_info['text'] if current_sentence_info else ""
            context_sentence_id = current_sentence_info['sentence_id'] if current_sentence_info else -1
            
            # Êõ¥Êñ∞‰∏ä‰∏ÄËΩÆ‰∏ä‰∏ãÊñáÔºàÁî®‰∫é‰∏ãÊ¨°follow-upÔºâ
            self.previous_context_tokens = context_tokens.copy()
            self.previous_context_sentence = context_sentence
            self.previous_context_sentence_id = context_sentence_id
            self.last_used_tokens = context_tokens.copy()
            
        elif self.previous_context_tokens:
            # ÊÉÖÂÜµ2Ôºö‰∏ä‰∏ÄËΩÆÂØπËØù‰∏≠Â≠òÂú®ÈÄâ‰∏≠ÁöÑtokenÔºåËßÜ‰∏∫follow-up question
            print("üîÑ Inheriting previous round sentence reference, treating as follow-up question")
            context_tokens = self.previous_context_tokens
            context_sentence = self.previous_context_sentence
            context_sentence_id = self.previous_context_sentence_id
            is_follow_up = True
            
        else:
            # ÊÉÖÂÜµ3ÔºöÁ¶ÅÊ≠¢ÊèêÈóÆÔºåÊèêÁ§∫Áî®Êà∑ÈÄâÊã©Âè•Â≠ê
            print("‚ö†Ô∏è Prohibit question: No selected sentence and no previous context")
            self._show_selection_required_warning()
            return
        
        # ËæìÂá∫ÁªìÊûÑÂåñÊï∞ÊçÆ
        if context_tokens:
            self._output_structured_selection_data(
                context_tokens, 
                {'text': context_sentence, 'sentence_id': context_sentence_id}, 
                user_input=message
            )
        
        # Ê∑ªÂä†Áî®Êà∑Ê∂àÊÅØÂà∞ËÅäÂ§©ÁïåÈù¢
        if context_sentence:
            # ÊòæÁ§∫ÂºïÁî®ÁöÑÂè•Â≠ê
            quoted_text = context_sentence
            if is_follow_up:
                quoted_text = f"[Follow-up] {context_sentence}"
            self._add_chat_message("You", message, is_ai=False, quoted_text=quoted_text)
        else:
            self._add_chat_message("You", message, is_ai=False)
        
        # Convert to Sentence object and call MainAssistant
        sentence_object = self._convert_to_sentence_object(
            context_tokens, 
            context_sentence, 
            context_sentence_id, 
            message
        )
        
        # Call MainAssistant for AI response
        ai_response = self._call_main_assistant(sentence_object, message, context_tokens)
        self._add_chat_message("AI Assistant", ai_response, is_ai=True)
        
        # Save data after processing
        self._save_data()
        
        # Ê∏ÖÁ©∫ËæìÂÖ•
        self.chat_input.text = ''

    def _show_selection_required_warning(self):
        """ÊòæÁ§∫ÈúÄË¶ÅÈÄâÊã©Âè•Â≠êÁöÑË≠¶Âëä"""
        warning_message = "‚ö†Ô∏è Please select a relevant sentence before asking a question"
        print(f"üö´ {warning_message}")
        
        # Âú®ËÅäÂ§©ÁïåÈù¢ÊòæÁ§∫Ë≠¶ÂëäÊ∂àÊÅØ
        self._add_chat_message("System", warning_message, is_ai=True)
        
        # ÂèØÈÄâÔºöÂú®ËæìÂÖ•Ê°Ü‰∏äÊñπÊòæÁ§∫‰∏¥Êó∂ÊèêÁ§∫
        if hasattr(self, 'selection_label'):
            original_text = self.selection_label.text
            self.selection_label.text = warning_message
            self.selection_label.color = (1, 0.5, 0, 1)  # Ê©ôËâ≤Ë≠¶ÂëäËâ≤
            
            # 3ÁßíÂêéÊÅ¢Â§çÂéüÊñáÊú¨
            from kivy.clock import Clock
            def restore_text(dt):
                self.selection_label.text = original_text
                self.selection_label.color = (0.2, 0.2, 0.2, 1)  # ÊÅ¢Â§çÂéüËâ≤
            
            Clock.schedule_once(restore_text, 3.0)
    
    def _add_chat_message(self, sender, message, is_ai=False, quoted_text=None):
        """Ê∑ªÂä†ËÅäÂ§©Ê∂àÊÅØÂà∞ÁïåÈù¢"""
        # ÂàõÂª∫Ê∂àÊÅØÂÆπÂô®
        message_layout = BoxLayout(orientation='vertical', size_hint_y=None, height=160, padding=10)
        
        # ÂèëÈÄÅËÄÖÊ†áÁ≠æ
        sender_label = Label(
            text=sender,
            size_hint_y=None,
            height=40,
            color=(0.6, 0.6, 0.6, 1) if is_ai else (0.2, 0.6, 1, 1),
            halign='left',
            font_size=28
        )
        message_layout.add_widget(sender_label)
        
        # Â¶ÇÊûúÊúâÂºïÁî®ÁöÑÊñáÊú¨ÔºåÊòæÁ§∫ÂºïÁî®Ê†ºÂºè
        if quoted_text and not is_ai:
            quote_label = Label(
                text=f'Quote: "{quoted_text[:50]}{"..." if len(quoted_text) > 50 else ""}"',
                size_hint_y=None,
                height=60,
                color=(0.5, 0.5, 0.5, 1),
                text_size=(None, None),
                halign='left',
                valign='top',
                font_size=24
            )
            message_layout.add_widget(quote_label)
            message_label = Label(
                text=f'Says: {message}',
                size_hint_y=None,
                height=60,
                color=(0.2, 0.2, 0.2, 1),
                text_size=(None, None),
                halign='left',
                valign='top',
                font_size=28
            )
            message_layout.add_widget(message_label)
        else:
            message_label = Label(
                text=message,
                size_hint_y=None,
                height=120,
                color=(0.2, 0.2, 0.2, 1),
                text_size=(None, None),
                halign='left',
                valign='top',
                font_size=28
            )
            message_layout.add_widget(message_label)
        
        self.chat_container.add_widget(message_layout)
        Clock.schedule_once(lambda dt: setattr(self.chat_scroll, 'scroll_y', 0), 0.1)
    
    def _generate_ai_response(self, user_message, selected_text):
        """ÁîüÊàêAIÂõûÂ§ç - ÊµãËØïÁâàÊú¨"""
        # ÊµãËØïÁâàÊú¨ÁöÑAIÂõûÂ§çÈÄªËæë
        if selected_text:
            if "meaning" in user_message.lower() or "ÊÑèÊÄù" in user_message:
                return f"About the selected text '{selected_text[:30]}...' meaning, this is a great question. Let me explain..."
            elif "grammar" in user_message.lower() or "ËØ≠Ê≥ï" in user_message:
                return f"The selected text '{selected_text[:30]}...' involves some grammar points. Let me analyze..."
            elif "pronunciation" in user_message.lower() or "ÂèëÈü≥" in user_message:
                return f"Regarding the pronunciation of '{selected_text[:30]}...', here are some key points to note..."
            else:
                return f"You asked about the selected text '{selected_text[:30]}...' question. This is a great learning point!"
        else:
            if "help" in user_message.lower() or "Â∏ÆÂä©" in user_message:
                return "I can help you learn languages! Please select any text from the article and ask me questions about grammar, vocabulary, pronunciation, or meaning."
            elif "hello" in user_message.lower() or "‰Ω†Â•Ω" in user_message:
                return "Hello! I am your language learning assistant. Please select text from the article, and I will answer your questions."
            else:
                return "Please select some text from the article first, then ask me related questions. I can help you understand grammar, vocabulary, pronunciation, etc."
    
    def backup_selected_text(self):
        """Â§á‰ªΩÈÄâ‰∏≠ÁöÑÊñáÊú¨"""
        if self.article_content_widget.selection_text:
            self.selected_text_backup = self.article_content_widget.selection_text
            self.is_text_selected = True
            print(f"üìù Backing up selected text: '{self.selected_text_backup[:30]}...'")
        elif self.selected_text_backup and self.is_text_selected:
            # Â¶ÇÊûúÂΩìÂâçÊ≤°ÊúâÈÄâÊã©‰ΩÜÊúâÂ§á‰ªΩÔºå‰øùÊåÅÂ§á‰ªΩÁä∂ÊÄÅ
            print(f"üìù Keeping backup text: '{self.selected_text_backup[:30]}...'")
        else:
            # Ê≤°ÊúâÈÄâÊã©‰πüÊ≤°ÊúâÂ§á‰ªΩ
            self.selected_text_backup = ""
            self.is_text_selected = False
            print("üìù No selected text")
    
    def clear_text_selection(self):
        """Ê∏ÖÈô§ÊñáÊú¨ÈÄâÊã©"""
        self.selected_text_backup = ""
        self.is_text_selected = False
        print("üìù Clearing text selection")
    
    # ËÉåÊôØÊõ¥Êñ∞ÊñπÊ≥ï
    def _update_article_title_bg(self, *args):
        if hasattr(self, 'article_title_bg'):
            self.article_title_bg.pos = args[0].pos
            self.article_title_bg.size = args[0].size
    
    def _update_chat_title_bg(self, *args):
        if hasattr(self, 'chat_title_bg'):
            self.chat_title_bg.pos = args[0].pos
            self.chat_title_bg.size = args[0].size
    
    def _update_selection_label_bg(self, *args):
        if hasattr(self, 'selection_label_bg'):
            self.selection_label_bg.pos = args[0].pos
            self.selection_label_bg.size = args[0].size
    
    def _update_chat_scroll_bg(self, *args):
        if hasattr(self, 'chat_scroll_bg'):
            self.chat_scroll_bg.pos = self.chat_scroll.pos
            self.chat_scroll_bg.size = self.chat_scroll.size
    
    def _update_chat_container_bg(self, *args):
        if hasattr(self, 'chat_container_bg'):
            self.chat_container_bg.pos = self.chat_container.pos
            self.chat_container_bg.size = self.chat_container.size
    
    def _update_token_bg(self, instance, value):
        """Êõ¥Êñ∞tokenËÉåÊôØ"""
        if hasattr(instance, 'token_bg'):
            instance.token_bg.pos = instance.pos
            instance.token_bg.size = instance.size
    
    def _check_sentence_boundary(self, token_index):
        """Ê£ÄÊü•tokenÊòØÂê¶Âú®ÂΩìÂâçÈÄâÊã©Âè•Â≠êÁöÑËæπÁïåÂÜÖ"""
        if not hasattr(self, 'sentence_boundaries') or not self.sentence_boundaries:
            return True
        
        # Â¶ÇÊûúÊ≤°ÊúâÂΩìÂâçÈÄâÊã©ÔºåÂÖÅËÆ∏ÈÄâÊã©
        if not self.selected_indices:
            return True
        
        # ÊâæÂà∞ÂΩìÂâçtokenÊâÄÂ±ûÁöÑÂè•Â≠ê
        current_sentence_id = None
        for boundary in self.sentence_boundaries:
            if boundary['start'] <= token_index <= boundary['end']:
                current_sentence_id = boundary['sentence_id']
                break
        
        if current_sentence_id is None:
            return False
        
        # Ê£ÄÊü•Â∑≤ÈÄâÊã©ÁöÑtokenÊòØÂê¶ÈÉΩÂú®Âêå‰∏Ä‰∏™Âè•Â≠êÂÜÖ
        for selected_index in self.selected_indices:
            selected_in_same_sentence = False
            for boundary in self.sentence_boundaries:
                if boundary['start'] <= selected_index <= boundary['end']:
                    if boundary['sentence_id'] == current_sentence_id:
                        selected_in_same_sentence = True
                    break
            if not selected_in_same_sentence:
                return False
        
        return True
    
    def _show_sentence_boundary_warning(self):
        """ÊòæÁ§∫Âè•Â≠êËæπÁïåË≠¶Âëä"""
        print("‚ö†Ô∏è Warning: Selection must be within the same sentence")
    
    def _on_token_touch_down(self, instance, touch):
        """tokenËß¶Êë∏Êåâ‰∏ã‰∫ã‰ª∂"""
        print(f"ÔøΩÔøΩ Token touch down - '{instance.token_text}' (index: {instance.token_index}), position: {touch.pos}")
        
        # Â¶ÇÊûúËß¶Êë∏‰∫ã‰ª∂Â∑≤ÁªèË¢´ÂÖ∂‰ªñÁªÑ‰ª∂ÊäìÂèñÔºå‰∏çÂ§ÑÁêÜ
        if touch.grab_current is not None:
            print(f"üîç Touch event already grabbed: {touch.grab_current}, not processing")
            return False
        
        if instance.collide_point(*touch.pos):
            import time
            current_time = time.time()
            
            print(f"üéØ Touched token: '{instance.token_text}' (index: {instance.token_index})")
            print(f"üîç Current drag state: {self.is_dragging}, grab state: {touch.grab_current}")
            print(f"üîç Sentence ID: {getattr(instance, 'sentence_id', 'N/A')}")
            
            # Ê£ÄÊü•ÊòØÂê¶ÊòØËøûÁª≠ÁÇπÂáª
            is_continuous_click = (current_time - self.last_touch_time) < self.touch_timeout
            
            if is_continuous_click and not self.is_dragging:
                # ËøûÁª≠ÁÇπÂáªÔºöÊ∑ªÂä†Âà∞ÈÄâÊã©‰∏≠ÔºàÈúÄË¶ÅÊ£ÄÊü•Âè•Â≠êËæπÁïåÔºâ
                if self._check_sentence_boundary(instance.token_index):
                    print(f"üéØ Continuous click, adding to selection: '{instance.token_text}'")
                    self.selected_indices.add(instance.token_index)
                    self._highlight_token(instance, True)
                else:
                    print("‚ö†Ô∏è Cross-sentence selection prevented")
                    self._show_sentence_boundary_warning()
            else:
                # Êñ∞ÁöÑÈÄâÊã©ÊàñÊãñÊãΩÂºÄÂßã
                if not self.is_dragging:
                    # Ê∏ÖÈô§‰πãÂâçÁöÑÈÄâÊã©
                    print("üîç Starting new selection, clearing previous selection")
                    self._clear_all_selections()
                    self.selected_indices.clear()
                
                # ÂºÄÂßãÈÄâÊã©
                self.selection_start_index = instance.token_index
                self.selection_end_index = instance.token_index
                self.is_dragging = True
                self.selected_indices.add(instance.token_index)
                
                # È´ò‰∫ÆÂΩìÂâçtoken
                self._highlight_token(instance, True)
            
            # Êõ¥Êñ∞ÈÄâÊã©Áä∂ÊÄÅ
            self._update_selection_from_tokens()
            self.last_touch_time = current_time
            
            # ÊäìÂèñËß¶Êë∏‰∫ã‰ª∂
            touch.grab(instance)
            print(f"üîç Token grabbed touch event: {touch.grab_current}")
            return True
        
        print(f"üîç Token touch position mismatch, not processing")
        return False
    
    def _on_token_touch_move(self, instance, touch):
        """tokenËß¶Êë∏ÁßªÂä®‰∫ã‰ª∂"""
        print(f"üîç Token touch move - '{instance.token_text}' (index: {instance.token_index}), position: {touch.pos}")
        print(f"üîç Grab state: {touch.grab_current}, drag state: {self.is_dragging}")
        
        # Ê£ÄÊü•Ëß¶Êë∏‰∫ã‰ª∂ÊòØÂê¶Ë¢´ÂΩìÂâçtokenÊäìÂèñ
        if touch.grab_current != instance:
            print("üîç Token did not grab touch event, not processing")
            return False
        
        if not self.is_dragging:
            print("ÔøΩÔøΩ Not in drag state, not processing")
            return False
        
        # ÊâæÂà∞ÂΩìÂâçËß¶Êë∏ÁöÑtoken
        for token_widget in self.token_widgets:
            if token_widget.collide_point(*touch.pos):
                print(f"üéØ Dragged to token: '{token_widget.token_text}' (index: {token_widget.token_index})")
                
                # Ê£ÄÊü•Âè•Â≠êËæπÁïå
                if self._check_sentence_boundary(token_widget.token_index):
                    # Êõ¥Êñ∞ÈÄâÊã©ËåÉÂõ¥
                    self.selection_end_index = token_widget.token_index
                    
                    # ËÆ°ÁÆóÊãñÊãΩËåÉÂõ¥ÂÜÖÁöÑÊâÄÊúâÁ¥¢Âºï
                    start = min(self.selection_start_index, self.selection_end_index)
                    end = max(self.selection_start_index, self.selection_end_index)
                    
                    # Êõ¥Êñ∞ÈÄâ‰∏≠Á¥¢ÂºïÈõÜÂêà
                    self.selected_indices.clear()
                    for i in range(start, end + 1):
                        self.selected_indices.add(i)
                    
                    # ÈáçÊñ∞È´ò‰∫ÆÈÄâÊã©ËåÉÂõ¥
                    self._highlight_selection_range()
                    
                    # Êõ¥Êñ∞ÈÄâÊã©Áä∂ÊÄÅ
                    self._update_selection_from_tokens()
                else:
                    print("‚ö†Ô∏è Cross-sentence drag prevented")
                    self._show_sentence_boundary_warning()
                
                return True
        
        # Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞tokenÔºå‰ΩÜÊ≠£Âú®ÊãñÊãΩÔºå‰πüË¶ÅÂ§ÑÁêÜ
        if self.is_dragging:
            print("üéØ Dragged to blank area")
            return True
        
        print("üîç Drag state but no token found, not processing")
        return False
    
    def _on_token_touch_up(self, instance, touch):
        """tokenËß¶Êë∏Êä¨Ëµ∑‰∫ã‰ª∂"""
        print(f"üîç Token touch up - '{instance.token_text}' (index: {instance.token_index}), position: {touch.pos}")
        print(f"üîç Grab state: {touch.grab_current}, drag state: {self.is_dragging}")
        
        # Ê£ÄÊü•Ëß¶Êë∏‰∫ã‰ª∂ÊòØÂê¶Ë¢´ÂΩìÂâçtokenÊäìÂèñ
        if touch.grab_current != instance:
            print("üîç Token did not grab touch event, not processing")
            return False
        
        if self.is_dragging:
            print(f"üéØ Ending drag, selection range: {self.selection_start_index} - {self.selection_end_index}")
            print(f"üéØ Selected indices: {sorted(self.selected_indices)}")
            self.is_dragging = False
            
            # Á°Æ‰øùÈÄâÊã©ËåÉÂõ¥Ê≠£Á°ÆÔºàstart <= endÔºâ
            if self.selection_start_index > self.selection_end_index:
                self.selection_start_index, self.selection_end_index = self.selection_end_index, self.selection_start_index
            
            # ÊúÄÁªàÊõ¥Êñ∞ÈÄâÊã©Áä∂ÊÄÅ
            self._update_selection_from_tokens()
            
            # ÈáäÊîæËß¶Êë∏ÊäìÂèñ
            touch.ungrab(instance)
            print("üîç Token released touch grab (drag ended)")
            return True
        
        # ÈáäÊîæËß¶Êë∏ÊäìÂèñ
        touch.ungrab(instance)
        print("üîç Token released touch grab (non-drag)")
        return False
    
    def _clear_all_selections(self):
        """Ê∏ÖÈô§ÊâÄÊúâÈÄâÊã©"""
        print(f"üîç Clearing all selections - current state: drag={self.is_dragging}, selected indices={sorted(self.selected_indices)}")
        
        for token_widget in self.token_widgets:
            self._highlight_token(token_widget, False)
        self.selected_indices.clear()
        self.selection_start_index = -1
        self.selection_end_index = -1
        # ÈáçÁΩÆÊãñÊãΩÁä∂ÊÄÅ
        self.is_dragging = False
        
        print(f"üîç Clearing complete - new state: drag={self.is_dragging}, selected indices={sorted(self.selected_indices)}")
    
    def _highlight_token(self, token_widget, is_selected):
        """È´ò‰∫ÆÊàñÂèñÊ∂àÈ´ò‰∫Ætoken"""
        token_widget.is_selected = is_selected
        
        # Êõ¥Êñ∞ËÉåÊôØÈ¢úËâ≤
        if hasattr(token_widget, 'token_bg'):
            # Ê∏ÖÈô§Áé∞ÊúâÁöÑËÉåÊôØ
            token_widget.canvas.before.clear()
            
            # ÈáçÊñ∞ÂàõÂª∫ËÉåÊôØ
            with token_widget.canvas.before:
                if is_selected:
                    Color(0.2, 0.6, 1, 0.3)  # ËìùËâ≤È´ò‰∫Æ
                else:
                    Color(1, 1, 1, 1)  # ÁôΩËâ≤ËÉåÊôØ
                token_widget.token_bg = Rectangle(pos=token_widget.pos, size=token_widget.size)
    
    def _highlight_selection_range(self):
        """È´ò‰∫ÆÈÄâÊã©ËåÉÂõ¥ÂÜÖÁöÑÊâÄÊúâtoken"""
        # Ê∏ÖÈô§ÊâÄÊúâÈÄâÊã©
        for token_widget in self.token_widgets:
            self._highlight_token(token_widget, False)
        
        # È´ò‰∫ÆÊâÄÊúâÈÄâ‰∏≠ÁöÑtoken
        for index in self.selected_indices:
            if 0 <= index < len(self.token_widgets):
                self._highlight_token(self.token_widgets[index], True)
    
    def _get_full_sentence_info(self, token_indices):
        """Ê†πÊçÆtokenÁ¥¢ÂºïËé∑ÂèñÂÆåÊï¥Âè•Â≠ê‰ø°ÊÅØ"""
        if not token_indices or not hasattr(self, 'sentence_boundaries'):
            return None
        
        # ÊâæÂà∞Á¨¨‰∏Ä‰∏™tokenÊâÄÂ±ûÁöÑÂè•Â≠ê
        first_token_index = min(token_indices)
        sentence_info = None
        
        for boundary in self.sentence_boundaries:
            if boundary['start'] <= first_token_index <= boundary['end']:
                sentence_info = boundary
                break
        
        return sentence_info
    
    def _output_structured_selection_data(self, selected_tokens, sentence_info, user_input=None):
        """ËæìÂá∫ÁªìÊûÑÂåñÈÄâÊã©Êï∞ÊçÆ"""
        if not sentence_info:
            print("‚ö†Ô∏è Unable to find sentence information")
            return
        
        # ÊûÑÈÄ†ÁªìÊûÑÂåñÊï∞ÊçÆ
        structured_data = {
            'selected_tokens': selected_tokens,
            'full_sentence': sentence_info['text'],
            'sentence_id': sentence_info['sentence_id'],
            'text_id': getattr(self, 'article_id', 0)  # ÊñáÁ´†IDÔºåÈªòËÆ§‰∏∫0
        }
        
        # Â¶ÇÊûúÊúâÁî®Êà∑ËæìÂÖ•ÔºåÊ∑ªÂä†Âà∞ÁªìÊûÑÂåñÊï∞ÊçÆ‰∏≠
        if user_input is not None:
            structured_data['user_input'] = user_input
        
        print("üéØ Structured Selection Data:")
        print(f"   selected_tokens: {structured_data['selected_tokens']}")
        print(f"   full_sentence: '{structured_data['full_sentence']}'")
        print(f"   sentence_id: {structured_data['sentence_id']}")
        print(f"   text_id: {structured_data['text_id']}")
        if user_input is not None:
            print(f"   user_input: '{structured_data['user_input']}'")
        print("üìä Complete Data Structure:")
        print(structured_data)
    
    def _update_selection_from_tokens(self):
        """‰ªétokenÈÄâÊã©Êõ¥Êñ∞ÈÄâÊã©Áä∂ÊÄÅ"""
        if self.selected_indices:
            # ÊûÑÈÄ†ÈÄâ‰∏≠ÁöÑÊñáÊú¨
            selected_tokens = []
            for i in sorted(self.selected_indices):
                if 0 <= i < len(self.tokens):
                    selected_tokens.append(self.tokens[i])
            
            selected_text = " ".join(selected_tokens)
            
            # Êõ¥Êñ∞ÈÄâÊã©Áä∂ÊÄÅ
            self.selected_text_backup = selected_text
            self.is_text_selected = True
            
            print(f"üìù Updating selection: '{selected_text}' (indices: {sorted(self.selected_indices)})")
            
            # Ëé∑ÂèñÂÆåÊï¥Âè•Â≠ê‰ø°ÊÅØÂπ∂ËæìÂá∫ÁªìÊûÑÂåñÊï∞ÊçÆ
            sentence_info = self._get_full_sentence_info(self.selected_indices)
            self._output_structured_selection_data(selected_tokens, sentence_info)
            
            # Êõ¥Êñ∞ÊòæÁ§∫
            self._update_selection_display()
        else:
            self.selected_text_backup = ""
            self.is_text_selected = False
            self._update_selection_display()
    
    def _on_container_touch_down(self, instance, touch):
        """ÂÆπÂô®Ëß¶Êë∏‰∫ã‰ª∂ÔºåÁî®‰∫éÁÇπÂáªÁ©∫ÁôΩÂ§ÑÂèñÊ∂àÈÄâÊã©"""
        print(f"üîç Container touch down - position: {touch.pos}, current drag state: {self.is_dragging}")
        
        # Â¶ÇÊûúËß¶Êë∏‰∫ã‰ª∂Â∑≤ÁªèË¢´ÂÖ∂‰ªñÁªÑ‰ª∂ÊäìÂèñÔºå‰∏çÂ§ÑÁêÜ
        if touch.grab_current is not None:
            print(f"üîç Touch event already grabbed: {touch.grab_current}, not processing")
            return False
        
        # Ê£ÄÊü•ÊòØÂê¶ÁÇπÂáª‰∫Ü‰ªª‰Ωïtoken
        for token_widget in self.token_widgets:
            if token_widget.collide_point(*touch.pos):
                # ÁÇπÂáª‰∫ÜtokenÔºå‰∏çÂ§ÑÁêÜÔºàÁî±tokenËá™Â∑±ÁöÑ‰∫ã‰ª∂Â§ÑÁêÜÔºâ
                print(f"üîç Clicked on token: '{token_widget.token_text}', not processing")
                return False
        
        # ÁÇπÂáª‰∫ÜÁ©∫ÁôΩÂ§ÑÔºåÊ∏ÖÈô§ÊâÄÊúâÈÄâÊã©
        print("üéØ Clicked blank area, clearing all selections")
        print(f"üîç State before clearing - drag: {self.is_dragging}, selected indices: {sorted(self.selected_indices)}")
        
        # ÈáçÁΩÆÊãñÊãΩÁä∂ÊÄÅ
        self.is_dragging = False
        self._clear_all_selections()
        self._update_selection_from_tokens()
        
        print(f"üîç State after clearing - drag: {self.is_dragging}, selected indices: {sorted(self.selected_indices)}")
        
        # Ê†áËÆ∞Ëøô‰∏™Ëß¶Êë∏‰∫ã‰ª∂Â∑≤ÁªèË¢´Â§ÑÁêÜÔºåÈò≤Ê≠¢ÂêéÁª≠‰º†Êí≠
        touch.grab(instance)
        print(f"üîç Touch event grabbed: {touch.grab_current}")
        return True
    
    def _on_container_touch_move(self, instance, touch):
        """ÂÆπÂô®Ëß¶Êë∏ÁßªÂä®‰∫ã‰ª∂"""
        print(f"üîç Container touch move - position: {touch.pos}, grab state: {touch.grab_current}")
        
        # Â¶ÇÊûúËß¶Êë∏‰∫ã‰ª∂Ë¢´ÂÆπÂô®ÊäìÂèñÔºåÂ§ÑÁêÜÁßªÂä®‰∫ã‰ª∂
        if touch.grab_current == instance:
            print("üîç Container has grabbed touch event, processing move")
            
            # Ê£ÄÊü•ÊòØÂê¶ÁßªÂä®Âà∞‰∫Ü‰ªª‰Ωïtoken
            for token_widget in self.token_widgets:
                if token_widget.collide_point(*touch.pos):
                    # ÁßªÂä®Âà∞‰∫ÜtokenÔºåÈáäÊîæÊäìÂèñËÆ©tokenÂ§ÑÁêÜ
                    print(f"ÔøΩÔøΩ Moved to token: '{token_widget.token_text}', releasing grab")
                    touch.ungrab(instance)
                    return False
            
            # ÁªßÁª≠Âú®Á©∫ÁôΩÂå∫ÂüüÁßªÂä®Ôºå‰øùÊåÅÊäìÂèñ
            print("üîç Continue moving in blank area, maintaining grab")
            return True
        
        print("üîç Container has not grabbed touch event, not processing")
        return False
    
    def _on_container_touch_up(self, instance, touch):
        """ÂÆπÂô®Ëß¶Êë∏Êä¨Ëµ∑‰∫ã‰ª∂"""
        print(f"üîç Container touch up - position: {touch.pos}, grab state: {touch.grab_current}")
        
        # Â¶ÇÊûúËß¶Êë∏‰∫ã‰ª∂Ë¢´ÂÆπÂô®ÊäìÂèñÔºåÈáäÊîæÊäìÂèñ
        if touch.grab_current == instance:
            print("üîç Container releasing touch grab")
            touch.ungrab(instance)
            return True
        
        print("üîç Container has not grabbed touch event, not processing")
        return False
    
    def test_run(self):
        """ÊµãËØïËøêË°åÂäüËÉΩ - ‰ΩøÁî®ÊµãËØïÊï∞ÊçÆËøêË°åÂΩìÂâçÈ°µÈù¢"""
        print("üß™ Starting test run for TextInputChatScreenTest...")
        
        # ËÆæÁΩÆÊµãËØïÊñáÁ´†Êï∞ÊçÆ
        test_article_data = self._create_test_article_data()
        self.set_article(test_article_data)
        
        # Ê∑ªÂä†‰∏Ä‰∫õÊµãËØïÊ∂àÊÅØ
        self._add_test_messages()
        
        print("‚úÖ Test data setup complete")
        print("üìñ Article Title:", self.article_title)
        print("üìù Article content length:", len(self.article_content))
        print("üí¨ Number of chat messages:", len(self.chat_history))
    
    def _create_test_article_data(self):
        """ÂàõÂª∫ÊµãËØïÊñáÁ´†Êï∞ÊçÆ"""
        class TestArticleData:
            def __init__(self):
                self.text_id = 3  # ËÆæÁΩÆÊñáÁ´†ID
                self.text_title = "The Internet and Language Learning"
                self.text_by_sentence = [
                    type('MockSentence', (), {'sentence_body': 'The internet has revolutionized the way we learn languages.'})(),
                    type('MockSentence', (), {'sentence_body': 'With the advent of online platforms, mobile applications, and digital resources, language learning has become more accessible than ever before.'})(),
                    type('MockSentence', (), {'sentence_body': 'Online language learning platforms offer a variety of features that traditional classroom settings cannot provide.'})(),
                    type('MockSentence', (), {'sentence_body': 'These include interactive exercises, real-time feedback, personalized learning paths, and access to native speakers from around the world.'})(),
                    type('MockSentence', (), {'sentence_body': 'One of the most significant advantages of internet-based language learning is the availability of authentic materials.'})(),
                    type('MockSentence', (), {'sentence_body': 'Learners can access real news articles, videos, podcasts, and social media content in their target language.'})(),
                    type('MockSentence', (), {'sentence_body': 'Furthermore, the internet facilitates collaborative learning through online communities and language exchange programs.'})(),
                    type('MockSentence', (), {'sentence_body': 'Students can connect with peers from different countries, practice conversation skills, and share cultural insights.'})()
                ]
        
        return TestArticleData()
    
    def _add_test_messages(self):
        """Ê∑ªÂä†ÊµãËØïËÅäÂ§©Ê∂àÊÅØ"""
        # Ê®°ÊãüÁî®Êà∑ÈÄâÊã©ÊñáÊú¨Âπ∂ÊèêÈóÆ
        test_scenarios = [
            {
                'selected_text': 'revolutionized',
                'user_message': 'What does this word mean?',
                'ai_response': 'revolutionized means "to completely change or transform something in a fundamental way." It comes from the word "revolution" and is often used to describe major technological or social changes.'
            },
            {
                'selected_text': 'the way we learn',
                'user_message': 'What grammar structure is used here?',
                'ai_response': 'This is a noun phrase structure: "the way we learn". Here, "the way" is a noun phrase meaning "the method or manner", and "we learn" is a relative clause that modifies "way". The relative pronoun "that" or "in which" is omitted.'
            },
            {
                'selected_text': '',
                'user_message': 'Can you help me understand this article?',
                'ai_response': 'Of course! This article discusses how the internet has changed language learning. It mentions online platforms, mobile apps, digital resources, and how they make language learning more accessible. Would you like me to explain any specific part in detail?'
            }
        ]
        
        for scenario in test_scenarios:
            # Ê®°ÊãüÊñáÊú¨ÈÄâÊã©
            if scenario['selected_text']:
                self._on_text_selection_change(None, scenario['selected_text'])
                print(f"üìù Simulating text selection: '{scenario['selected_text']}'")
            
            # Ê∑ªÂä†Áî®Êà∑Ê∂àÊÅØ
            self._add_chat_message("You", scenario['user_message'], is_ai=False, quoted_text=scenario['selected_text'] if scenario['selected_text'] else None)
            
            # Ê∑ªÂä†AIÂõûÂ§ç
            self._add_chat_message("Test AI Assistant", scenario['ai_response'], is_ai=True)
            
            # Ê∏ÖÈô§ÈÄâÊã©Áä∂ÊÄÅ
            if scenario['selected_text']:
                self._on_text_selection_change(None, "")
        
        print(f"‚úÖ Added {len(test_scenarios)} test conversation scenarios") 