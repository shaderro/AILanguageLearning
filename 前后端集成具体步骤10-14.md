# 前后端集成具体步骤 (2024-10-14)

## 🔍 当前状况分析

### 重要发现！你的 `server.py` 已经准备好了！

我查看了你的代码，发现一个好消息：

**根目录的 `server.py`（端口8001）并不只是关于 Asked Tokens！**

它实际上已经集成了：
- ✅ **Vocab API（数据库版本）** - `/api/v2/vocab/*`
- ✅ **Grammar API（数据库版本）** - `/api/v2/grammar/*`
- ✅ **Text API（数据库版本）** - `/api/v2/texts/*`
- ⚠️ **Asked Tokens（JSON版本）** - `/api/user/asked-tokens`（临时）

### 代码证据

```python
# server.py 第24-47行

# 导入API路由（这些是数据库版本！）
from backend.api import vocab_router, grammar_router, text_router
from backend.api.vocab_routes_verbose import router as vocab_verbose_router

# 注册API路由
app.include_router(vocab_router)        # ← Vocab数据库API
app.include_router(vocab_verbose_router)  # ← Vocab详细日志版
app.include_router(grammar_router)      # ← Grammar数据库API
app.include_router(text_router)         # ← Text数据库API
```

**这意味着**：你的数据库API已经可用，只需要前端连接过来！

---

## 📊 两个服务器对比

| 特性 | server.py<br/>(端口8001) | server_frontend_mock.py<br/>(端口8000) |
|------|------------------------|-----------------------------------|
| **位置** | 根目录 | frontend/my-web-ui/backend/ |
| **用途** | 🎯 生产API服务器 | 🔧 前端开发Mock |
| **Vocab** | ✅ 数据库版本 | 🔴 Mock数据 |
| **Grammar** | ✅ 数据库版本 | 🔴 Mock数据 |
| **Text** | ✅ 数据库版本 | 🔴 Mock数据 |
| **AskedTokens** | ⚠️ JSON版本（临时） | 🔴 Mock数据 |
| **Dialogue** | ❌ 未实现 | ✅ Mock数据（含SessionState） |
| **数据持久化** | ✅ SQLite数据库 | ❌ 临时数据 |
| **推荐用途** | **生产和真实开发** | 仅前端原型开发 |

---

## 🎯 集成步骤（两种方案）

### 方案1：最简单方案（15分钟）⭐ 推荐快速验证

**只改一行配置，立即使用数据库API**

#### 步骤1.1：修改前端API配置

**文件**：`frontend/my-web-ui/src/services/api.js`

**改动**：
```javascript
// 找到第5行（baseURL配置）

// 旧的（Mock API）
const api = axios.create({
  baseURL: "http://localhost:8000",  // ← 改这里
  timeout: 60000,
  // ...
});

// 新的（真实数据库API）
const api = axios.create({
  baseURL: "http://localhost:8001",  // ← 改为8001
  timeout: 60000,
  // ...
});
```

#### 步骤1.2：更新API端点路径

**文件**：`frontend/my-web-ui/src/services/api.js`

找到并更新这些方法：

```javascript
// Vocab API - 更新路径
export const apiService = {
  // 旧：getVocabList: () => api.get("/api/vocab"),
  getVocabList: () => api.get("/api/v2/vocab"),  // ← 加 /v2

  // 旧：getVocabById: (id) => api.get(`/api/vocab/${id}`),
  getVocabById: (id) => api.get(`/api/v2/vocab/${id}`),  // ← 加 /v2

  // Grammar API - 更新路径
  // 旧：getGrammarList: () => api.get("/api/grammar"),
  getGrammarList: () => api.get("/api/v2/grammar"),  // ← 加 /v2

  // 旧：getGrammarById: (id) => api.get(`/api/grammar/${id}`),
  getGrammarById: (id) => api.get(`/api/v2/grammar/${id}`),  // ← 加 /v2

  // Text/Article API - 更新路径
  // 旧：getArticlesList: () => api.get("/api/articles"),
  getArticlesList: () => api.get("/api/v2/texts"),  // ← 改为 /api/v2/texts

  // 旧：getArticleById: (id) => api.get(`/api/articles/${id}`),
  getArticleById: (id) => api.get(`/api/v2/texts/${id}?include_sentences=true`),  // ← 改路径+参数

  // AskedTokens - 保持不变（仍然用旧端点）
  getAskedTokens: (userId, textId) => 
    api.get(`/api/user/asked-tokens?user_id=${userId}&text_id=${textId}`),  // ← 不变
};
```

#### 步骤1.3：处理响应格式差异

**数据库API返回格式**：
```json
{
  "success": true,
  "data": { ... },
  "error": null
}
```

**Mock API返回格式**：
```json
{
  "data": { ... }
}
```

**解决方案**：更新响应拦截器

```javascript
// frontend/my-web-ui/src/services/api.js

// 响应拦截器
api.interceptors.response.use(
  (response) => {
    console.log("API Response:", response.status, response.config.url);
    
    // 兼容数据库API格式
    if (response.data && response.data.success !== undefined) {
      // 数据库API格式：{ success: true, data: {...} }
      return response.data.data;  // ← 返回内层data
    }
    
    // Mock API格式：直接返回
    return response.data;
  },
  (error) => {
    console.error("API Response Error:", error?.response?.status, error?.message);
    return Promise.reject(error);
  }
);
```

#### 步骤1.4：启动服务器测试

```powershell
# 终端1：启动真实API
cd C:\Users\Mayn\AILanguageLearning-main
python server.py
# 访问 http://localhost:8001/docs 验证API

# 终端2：启动前端
cd C:\Users\Mayn\AILanguageLearning-main\frontend\my-web-ui
npm run dev
# 访问 http://localhost:5173
```

**完成！** 前端现在使用数据库API了。

---

### 方案2：专业方案（使用API代理层，2小时）

参考 `前后端集成方案对比10-14.md` 中的方案C。

---

## 📝 需要改动的文件清单

### 方案1（最简单）

| 文件 | 改动内容 | 行数 | 难度 |
|------|---------|------|------|
| `frontend/my-web-ui/src/services/api.js` | 修改baseURL和端点路径 | ~20行 | 🟢 简单 |

**就这一个文件！**

### 方案2（API代理层）

| 文件 | 改动内容 | 行数 | 难度 |
|------|---------|------|------|
| `frontend/my-web-ui/src/config/apiConfig.js` | 创建配置文件 | ~100行 | 🟢 简单 |
| `frontend/my-web-ui/src/services/apiProxy.js` | 创建代理层 | ~80行 | 🟡 中等 |
| `frontend/my-web-ui/src/services/api.js` | 重构使用代理 | ~50行 | 🟡 中等 |

---

## 🔧 详细改动示例

### 完整的 api.js 改动（方案1）

**文件**：`frontend/my-web-ui/src/services/api.js`

```javascript
import axios from "axios";

// 创建 axios 实例 - 连接到真实数据库API
const api = axios.create({
  baseURL: "http://localhost:8001",  // ← 改为8001（数据库API）
  timeout: 60000,
  headers: {
    "Content-Type": "application/json",
  },
});

// 请求拦截器
api.interceptors.request.use(
  (config) => {
    console.log("API Request:", config.method?.toUpperCase(), config.url);
    return config;
  },
  (error) => {
    console.error("API Request Error:", error);
    return Promise.reject(error);
  }
);

// 响应拦截器 - 处理数据库API格式
api.interceptors.response.use(
  (response) => {
    console.log("API Response:", response.status, response.config.url);
    
    // 数据库API返回 { success: true, data: {...} }
    if (response.data && response.data.success !== undefined) {
      return response.data.data;  // 返回内层data
    }
    
    // 其他格式直接返回
    return response.data;
  },
  (error) => {
    console.error("API Response Error:", error?.response?.status, error?.message);
    return Promise.reject(error);
  }
);

// API 服务
export const apiService = {
  // ==================== 健康检查 ====================
  healthCheck: () => api.get("/api/health"),

  // ==================== Vocab API ====================
  
  // 获取词汇列表
  getVocabList: () => api.get("/api/v2/vocab"),  // ← 改为 /v2

  // 获取单个词汇
  getVocabById: (id) => api.get(`/api/v2/vocab/${id}`),  // ← 改为 /v2

  // 搜索词汇
  searchVocab: (keyword) => 
    api.get(`/api/v2/vocab/search?keyword=${encodeURIComponent(keyword)}`),  // ← 改为 /v2

  // 创建词汇
  createVocab: (vocabData) => api.post("/api/v2/vocab", vocabData),  // ← 改为 /v2

  // 更新词汇
  updateVocab: (id, vocabData) => api.put(`/api/v2/vocab/${id}`, vocabData),  // ← 改为 /v2

  // 删除词汇
  deleteVocab: (id) => api.delete(`/api/v2/vocab/${id}`),  // ← 改为 /v2

  // ==================== Grammar API ====================
  
  // 获取语法列表
  getGrammarList: () => api.get("/api/v2/grammar"),  // ← 改为 /v2

  // 获取单个语法规则
  getGrammarById: (id) => api.get(`/api/v2/grammar/${id}`),  // ← 改为 /v2

  // 搜索语法
  searchGrammar: (keyword) => 
    api.get(`/api/v2/grammar/search?keyword=${encodeURIComponent(keyword)}`),  // ← 改为 /v2

  // 创建语法规则
  createGrammar: (grammarData) => api.post("/api/v2/grammar", grammarData),  // ← 改为 /v2

  // 更新语法规则
  updateGrammar: (id, grammarData) => api.put(`/api/v2/grammar/${id}`, grammarData),  // ← 改为 /v2

  // 删除语法规则
  deleteGrammar: (id) => api.delete(`/api/v2/grammar/${id}`),  // ← 改为 /v2

  // ==================== Text/Article API ====================
  
  // 获取文章列表
  getArticlesList: () => api.get("/api/v2/texts"),  // ← 改为 /v2/texts

  // 获取文章详情
  getArticleById: (id) => 
    api.get(`/api/v2/texts/${id}?include_sentences=true`),  // ← 改为 /v2/texts + 参数

  // 获取文章的句子
  getArticleSentences: (textId) => 
    api.get(`/api/v2/texts/${textId}/sentences`),  // ← 新增

  // 搜索文章
  searchArticles: (keyword) => 
    api.get(`/api/v2/texts/search?keyword=${encodeURIComponent(keyword)}`),  // ← 改为 /v2/texts

  // ==================== Asked Tokens API ====================
  // 注意：暂时保持旧端点，因为数据结构未最终确定
  
  // 获取已提问的tokens
  getAskedTokens: (userId, textId) => 
    api.get(`/api/user/asked-tokens?user_id=${userId}&text_id=${textId}`),  // ← 保持不变

  // 标记token为已提问
  markAskedToken: (userId, textId, sentenceId, tokenId) => 
    api.post("/api/user/asked-tokens", {
      user_id: userId,
      text_id: textId,
      sentence_id: sentenceId,
      sentence_token_id: tokenId,
    }),  // ← 保持不变

  // ==================== 统计 API ====================
  
  // 获取统计数据（如果Mock API有，可能需要调整）
  getStats: () => api.get("/api/stats"),
};

export default apiService;
```

---

## 🧪 测试验证步骤

### 1. 后端验证

```powershell
# 启动server.py
python server.py
```

访问 http://localhost:8001/docs 检查：
- ✅ `/api/v2/vocab` 端点存在
- ✅ `/api/v2/grammar` 端点存在
- ✅ `/api/v2/texts` 端点存在
- ✅ `/api/user/asked-tokens` 端点存在

**测试API**：
```bash
# 测试Vocab API
curl http://localhost:8001/api/v2/vocab

# 测试Grammar API
curl http://localhost:8001/api/v2/grammar

# 测试Text API
curl http://localhost:8001/api/v2/texts
```

### 2. 前端验证

```powershell
# 启动前端
cd frontend/my-web-ui
npm run dev
```

访问 http://localhost:5173

**检查浏览器控制台**：
- ✅ API请求指向 `http://localhost:8001`
- ✅ 响应返回真实数据库数据
- ✅ 无CORS错误

**功能测试**：
| 功能 | 预期结果 | 测试方法 |
|------|---------|---------|
| 词汇列表 | 显示29个词汇 | 访问词汇页面 |
| 语法列表 | 显示8个语法规则 | 访问语法页面 |
| 文章列表 | 显示7篇文章 | 访问文章页面 |
| 文章阅读 | 显示句子内容 | 打开任意文章 |
| 数据添加 | 保存到数据库 | 创建新词汇/语法 |

### 3. 数据持久化验证

```powershell
# 在前端创建一个新词汇
# 然后停止服务器，重新启动
python server.py

# 检查数据是否还在
curl http://localhost:8001/api/v2/vocab
```

应该能看到刚才创建的词汇 ✅

---

## ⚠️ 可能遇到的问题和解决

### 问题1：CORS错误

**症状**：
```
Access to XMLHttpRequest at 'http://localhost:8001' from origin 'http://localhost:5173' 
has been blocked by CORS policy
```

**原因**：server.py的CORS配置有问题

**解决**：检查server.py第34-41行
```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # ← 应该是 "*"
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

✅ 你的server.py已经正确配置，不会有这个问题。

---

### 问题2：数据格式不匹配

**症状**：前端显示空白或undefined

**原因**：前端组件期望的字段名和API返回的不同

**示例**：
```javascript
// Mock API返回
{ vocab_body: "Hallo" }

// 前端组件期望
item.word  // ← undefined!
```

**解决**：检查前端组件，看期望什么字段名

**方法1**：修改前端组件
```javascript
// 改为使用正确的字段名
{item.vocab_body}  // 而不是 {item.word}
```

**方法2**：在响应拦截器中转换
```javascript
api.interceptors.response.use(
  (response) => {
    let data = response.data.data || response.data;
    
    // 字段名转换（如果需要）
    if (Array.isArray(data)) {
      data = data.map(item => ({
        ...item,
        word: item.vocab_body,  // 添加别名
      }));
    }
    
    return data;
  }
);
```

---

### 问题3：文章数据结构不同

**症状**：文章页面显示不正常

**Mock API数据结构**：
```json
{
  "text_id": 1,
  "sentences": [
    {
      "tokens": [
        { "token_body": "Hallo" }  // ← token_body字段
      ]
    }
  ]
}
```

**数据库API数据结构**（可能）：
```json
{
  "text_id": 1,
  "sentences": [
    {
      "tokens": ()  // ← 空tuple（性能优化）
    }
  ]
}
```

**解决**：查看 `DATABASE_INTEGRATION_COMPLETE_SUMMARY.md` 中关于Token的说明。

如果前端需要Token详情，可能需要：
1. 单独的Token API（按需加载）
2. 或修改后端返回完整tokens

---

### 问题4：端口8001被占用

**症状**：
```
ERROR: [Errno 10048] error while attempting to bind on address ('0.0.0.0', 8001): 
通常每个套接字地址(协议/网络地址/端口)只允许使用一次。
```

**原因**：8001端口已被其他进程占用

**解决**：
```powershell
# 查找占用8001端口的进程
netstat -ano | findstr :8001

# 假设PID是12345
taskkill /PID 12345 /F

# 或者修改server.py使用其他端口
# 第210行改为：
uvicorn.run(app, host="0.0.0.0", port=8002)  # ← 改端口
```

---

## 📋 完整检查清单

### 后端准备
- [ ] 确认 `server.py` 在根目录
- [ ] 确认数据库文件存在（`database_system/data_storage/data/language_learning.db`）
- [ ] 确认数据库有数据（29个词汇、8个语法、7篇文章）
- [ ] 启动 `python server.py`，访问 http://localhost:8001/docs
- [ ] 测试 `/api/v2/vocab` 返回数据正常

### 前端修改
- [ ] 修改 `api.js` 的 baseURL 为 8001
- [ ] 更新所有API端点路径（加 `/v2`）
- [ ] 更新响应拦截器（处理数据库API格式）
- [ ] 更新文章API端点（`/api/articles` → `/api/v2/texts`）

### 测试验证
- [ ] 前端启动无错误
- [ ] 浏览器控制台显示请求到8001
- [ ] 词汇列表显示真实数据（29个）
- [ ] 语法列表显示真实数据（8个）
- [ ] 文章列表显示真实数据（7篇）
- [ ] 创建新词汇后刷新页面仍然存在（数据持久化）

### 功能验证
- [ ] 可以查看词汇详情
- [ ] 可以搜索词汇
- [ ] 可以创建/编辑词汇
- [ ] 可以查看语法详情
- [ ] 可以阅读文章
- [ ] AskedTokens功能正常（JSON版本）

---

## 🎯 下一步计划

### 完成集成后
1. ✅ 验证所有功能正常
2. 📝 记录发现的问题和解决方案
3. 🗑️ 移除或标记 `server_frontend_mock.py` 为已废弃

### 可选优化
1. 实现API代理层（方案C）
2. 添加Token按需加载功能
3. 优化数据库查询性能

### 等待功能设计完成
1. AskedTokens数据结构最终确定 → 切换到数据库版本
2. DialogueRecord功能设计完成 → 数据库适配

---

## 💡 总结

**关键发现**：
- ✅ 你的 `server.py` 已经集成了数据库API（Vocab、Grammar、Text）
- ✅ 前端只需改一个文件（`api.js`）就能连接数据库
- ✅ 工作量比想象的小得多（15-30分钟）

**推荐行动**：
1. **立即开始**：方案1（最简单集成）
2. **验证功能**：确保前端可以操作真实数据库
3. **发现问题**：记录任何数据格式不匹配
4. **考虑升级**：如果需要更灵活的管理，再实施方案C

**准备好开始了吗？我可以立即帮你修改 `api.js` 文件！** 🚀

---

**文档版本**：v1.0  
**创建日期**：2024-10-14  
**适用项目**：AI Language Learning

